
一、数据结构
	线性结构、非线性结构。

1.1、线性结构

	数据之间一对一的关系。分为顺序存储、链式存储。数组、队列、链表、栈。

1.2、非线性结构
	二维数组、多维数组、广义表、树结构、图结构。


二、数据结构和算法

2.1、稀疏数组和队列

2.1.1、稀疏数组sparseArray int[sum + 1][3] (解决多余无意义的数据)
	第一行记录的是数组大小，多少个值。从第二行开始，每一行记录非0数据的位置和值(下标从0开始)。
   --保存棋盘、地图等

2.1.2、例子	
  --五子棋

	图片五子棋.png  使用二维数组、稀疏数组记录棋盘
    ---棋盘：0：无子，1：黑子 2：蓝子
     二维数组：				稀疏数组：
					    row col val	
	0 0 0 0 0 0 0 0 0 0 0		    行 列 值
	0 0 1 0 0 0 0 0 0 0 0	<==	[0] 7  11 2	
	0 0 0 2	0 0 0 0 0 0 0		[1] 1  2  1
	0 0 0 0 0 0 0 0 0 0 0	==>	[2] 2  3  2
	0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0
	0 0 0 0 0 0 0 0 0 0 0

2.1.3、代码实现

	文件：SparseArray.java



2.2、队列
	先进先出、可用数组（顺序存储）、链表（链式储存）实现。
	front队头（出），rear队尾（进）

2.2.1、数组实现队列ArrayQueue
	
	front：指向当前出的队列元素 （该位置在队列中无数据 => 理论） 即第一个元素的前一个位置
	rear：当前队列最后一个元素	

	思路：
		满队列 -> rear == 数组长度 - 1
		空队列 -> rear == front
		添加队列 -> rear + 1
		推出队列 -> front + 1
		

	缺点：队列不可复用，只能使用一次。
						---文件：QueueArray.java
2.2.2、循环队列 ArrayCircularQueue

	将最后一个位置绕到第一个位置，形成逻辑上的环绕。
		--- 当数组最后一个存数据时，把数据存放到数组的第一个位置，最后一个位置永远为空。



2.2.3、例子
   ---银行排队案例
	银行排队系统.png

数组实现：
初始化：		            进：		        出：
	    0			        0		        0
	    0			        0		        0
	    0			        0		        0
	    0	   =>	        0		        0
	    0			        3 <-rear        3 <-rear
	    0			        2	    fornt->	2
front-> 0 <- rear   front-> 1 		        0


2.3、Linked List 链表（带头节点，不带头节点)
	
	带头结点：
			---头节点不带数据。
	不带头节点：
			---头节点带数据。

	储存结构，由数据域（放数据） + 指针域（放地址） 构成一个节点
		---增、删、该、查...

2.3.1 SingleLinkedList(环形annular 单项链表) 单向链表（带头、不带头节点）
	
 
	地址	data域		next域
	 118	  a3		  NULL
	 110	  a2		  118
	 130	  a1		  110


2.3.2 DoubleLinkedList 双向链表

	地址		pre域		data域		next域
	100		 NULL		  a1		  130
	120		 140		  a2		  NULL
	130		 100		  a3		  140
	140		 130		  a4		  120




2.4 栈Stack 

	先进后出
	
     ---图像
		入栈		出栈
	0		0		0
	0		0		0
	0	->	0		0
	0		1 <-top	0
	0		2 		2 <- top
	  <- top

2.5 树 Tree
    树是由节点、或定点和边组成。
        --图形
                    1
                  /   \
                 2     3
               / | \
              4  5  6
        图片： 树图解.png

2.5.1 二叉树
    所有叶子节点都在最后一层
        节点总数 = 2^n - 1,（n：层数）

二叉树遍历：父节点的输出顺序
    前序遍历：父左右
    中序遍历：左父右
    后序遍历：左右父

    满二叉树：   倒数第二层，所有节点都有左右子节点。
            总结点树：2^n - 1 (n：为层树)

    完全二叉树：   叶子节点在倒数第一次、倒数第二次，且每一层叶子节点的父节点都有左节点。





2.5 哈希表 Hash Table

2.6 数组 Array

2.7 堆 Heap

2.9 图 Graph




三、数据结构案例练习





四、算法案例练习

4.1、数组
    ---代码：
            ArrayExercise.java

4.1.1、原地算法
    1、删除排序数组中的重复项
        给你一个有序数组 nums，请你 原地 删除重复出现的元素，
    使每个元素只出现一次 ，返回删除后数组的新长度。不要使用额外
    的数组空间，你必须在 原地 修改输入数组并在使用 O(1) 额外空
    间的条件下完成。

    ---代码方法：
                removeRepeat

    2、旋转数组 (进阶解法：使用原地算法)
        给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

    ---代码方法：

4.1.2、贪心算法
    1、买卖股票的最佳时机
        给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
        设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

        ---注意：
                你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

    ---代码方法：
                maxProfit































